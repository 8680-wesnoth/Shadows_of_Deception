#textdomain wesnoth-NX-RPG

##
# List of spawn types available:
# ==============================
# - TIMED
#   This creates a unit during prestart that will respawn X turns after it is killed
#
# - RANDOM TIMED
#   This creates a unit during prestart at a random location that will respawn X turns
#   after it is killed, at a random location
#
# - ONETIME
#   This creates a unit in prestart
#
# - RANDOM ONETIME
#   This creates a unit in prestart at a random location
#
# - CONTINUOUS
#   This creates a unit in prestart and on a certain side's turn, every X turns
#
# - CONTINUOUS WITH MUF
#   This creates a unit in prestart and on a certain side's turn, every X turns that will
#   MUF from a given location first
#
# - RANDOM CONTINUOUS
#   This creates a unit in prestart and on a certain side's turn, every X turns,
#   at a random location
#
# - RANDOM CONTINUOUS WITH MUF
#   This creates a unit in prestart and on a certain side's turn, every X turns,
#   at a random location, that will MUF from a given location first
#
# NOTES
# =====
# - If you specify a comma-separated list of unit types in the UNIT_WML block,
#   the spawn type will be randomized every cycle.
#
# - A respawn interval of 0 turns will cause units to respawn immediately
#   after being killed.
#
# - It is possible to disable all spawners in a scenario by setting the
#   variable spawner_controller_enabled to a false boolean value. This is
#   initially set to true.
#
# Example:
#   {TIMED_SPAWNER 4 (type=Shaxthal Assault Drone,Shaxthal Sentry Drone) 2 42 10}
##

#define TIMED_SPAWNER _RESPAWN_TURNS _UNIT_WML _SIDE_NUMBER _X _Y
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}X{_X}Y{_Y}"
        first_time_only=no
        {SPAWNER_BASE ({_RESPAWN_TURNS}) ({_UNIT_WML}) ({_SIDE_NUMBER}) ({_X}) ({_Y})
        (yes) {SPAWNER_FUNCTION:RESPAWN}
        (no)  ()
        (no)  ()
        (no)}
    [/event]
#enddef

#define RANDOM_TIMED_SPAWNER _RESPAWN_TURNS _UNIT_WML _SIDE_NUMBER _X _Y _RAND_FORMULA
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}X{_X}Y{_Y}"
        first_time_only=no
        {SPAWNER_BASE ({_RESPAWN_TURNS}) ({_UNIT_WML}) ({_SIDE_NUMBER}) ({_X}) ({_Y})
        (yes) {SPAWNER_FUNCTION:RESPAWN}
        (yes) {SPAWNER_FUNCTION:RANDOM ({_RAND_FORMULA})}
        (no)  ()
        (no)}
    [/event]
#enddef

#define ONETIME_SPAWNER _UNIT_WML _SIDE_NUMBER _X _Y
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}X{_X}Y{_Y}"
        first_time_only=no
        {SPAWNER_BASE (0) ({_UNIT_WML}) ({_SIDE_NUMBER}) ({_X}) ({_Y})
        (no) ()
        (no) ()
        (no) ()
        (no)}
    [/event]
#enddef

#define RANDOM_ONETIME_SPAWNER _UNIT_WML _SIDE_NUMBER _X _Y _RAND_FORMULA
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}X{_X}Y{_Y}"
        first_time_only=no
        {SPAWNER_BASE (0) ({_UNIT_WML}) ({_SIDE_NUMBER}) ({_X}) ({_Y})
        (no)  ()
        (yes) {SPAWNER_FUNCTION:RANDOM ({_RAND_FORMULA})}
        (no)  ()
        (no)}
    [/event]
#enddef

#define CONTINUOUS_SPAWNER _UNIT_WML _SIDE_NUMBER _X _Y
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}X{_X}Y{_Y}"
        first_time_only=no
        {SPAWNER_BASE (0) ({_UNIT_WML}) ({_SIDE_NUMBER}) ({_X}) ({_Y})
        (no) ()
        (no) ()
        (no) ()
        (yes)}
    [/event]
#enddef

#define CONTINUOUS_SPAWNER_WITH_MUF _UNIT_WML _SIDE_NUMBER _X _Y _MUF_ORIGIN_FILTER
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}X{_X}Y{_Y}"
        first_time_only=no
        {SPAWNER_BASE (0) ({_UNIT_WML}) ({_SIDE_NUMBER}) ({_X}) ({_Y})
        (no)  ()
        (no)  ()
        (yes) {SPAWNER_FUNCTION:MUF ({_MUF_ORIGIN_FILTER})}
        (yes)}
    [/event]
#enddef

#define RANDOM_CONTINUOUS_SPAWNER _UNIT_WML _SIDE_NUMBER _RAND_FORMULA
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}XY"
        first_time_only=no
        {SPAWNER_BASE (0) ({_UNIT_WML}) ({_SIDE_NUMBER}) () ()
        (no)  ()
        (yes) {SPAWNER_FUNCTION:RANDOM ({_RAND_FORMULA})}
        (no)  ()
        (yes)}
    [/event]
#enddef

#define RANDOM_CONTINUOUS_SPAWNER_WITH_MUF _UNIT_WML _SIDE_NUMBER _RAND_FORMULA _MUF_ORIGIN_FILTER
    [event]
        name="prestart,respawn:S{_SIDE_NUMBER}XY}"
        first_time_only=no
        {SPAWNER_BASE (0) ({_UNIT_WML}) ({_SIDE_NUMBER}) () ()
        (no)  ()
        (yes) {SPAWNER_FUNCTION:RANDOM ({_RAND_FORMULA})}
        (yes) {SPAWNER_FUNCTION:MUF ({_MUF_ORIGIN_FILTER})}
        (yes)}
    [/event]
#enddef

##
# This is the main spawner logic. They macro must be present somewhere in
# the scenario at top level, preferably right before the first spawner
# macro inclusion.
#
# _SIDE_NUMBER and _TURN_CONDITION are args for the continuous spawner
##
#define SPAWNER_CONTROLLER _SIDE_NUMBER
    [event]
        name=prestart
        {VARIABLE spawner_controller_enabled yes}
        {VARIABLE continuous_spawner_units   ""}
        {VARIABLE continuous_turn ""}
    [/event]

    [event]
        name=victory
        {CLEAR_VARIABLE spawner_controller_enabled}
        {CLEAR_VARIABLE continuous_spawner_units}
        {CLEAR_VARIABLE continuous_turn}
    [/event]

    [event]
        name=die
        first_time_only=no
        [filter_condition]
            {VARIABLE_BOOLEAN_EQUALS spawner_controller_enabled yes}
        [/filter_condition]
        [filter]
            [filter_wml]
                [variables]
                    spawner_respawn=yes
                [/variables]
            [/filter_wml]
        [/filter]

        [if]
            {VARIABLE_NUMERICAL_LESS_THAN_OR_EQUAL unit.variables.spawner_turns 0}
            [then]
                {LOG_NX ("<SPAWN_CONTROLLER> fire '$unit.variables.spawner_event' now")}

                [kill]
                    x,y=$x1,$y1
                    fire_event=no
                    animate=no
                [/kill]

                [fire_event]
                    name="$unit.variables.spawner_event"
                [/fire_event]
            [/then]
            [else]
                [set_variables]
                    name="temp_spawner_event_store"
                    mode="replace"
                    [value]
                        name="turn $($turn_number + $unit.variables.spawner_turns)"
                        first_time_only="yes"
                        [fire_event]
                            name="$unit.variables.spawner_event"
                        [/fire_event]
                    [/value]
                [/set_variables]

                {LOG_NX ("<SPAWN_CONTROLLER> fire '$unit.variables.spawner_event' on turn $($turn_number + $unit.variables.spawner_turns)")}

                [insert_tag]
                    name="event"
                    variable="temp_spawner_event_store"
                [/insert_tag]

                {CLEAR_VARIABLE temp_spawner_event_store}
            [/else]
        [/if]
    [/event]

    [event]
        name=side_{_SIDE_NUMBER}_turn
        [filter_condition]
            {VARIABLE_NUMERICAL_EQUALS turn_number  $continuous_turn}
            {VARIABLE_BOOLEAN_EQUALS   spawner_controller_enabled yes}
        [/filter_condition]

        {FOREACH continuous_spawner_units i}
            [if]
                {VARIABLE_LEXICAL_EQUALS continuous_spawner_units[$i].variables.do_muf yes}
                [then]
                    [move_unit_fake]
                        type=$continuous_spawner_units[$i].type
                        side=$continuous_spawner_units[$i].side
                        x=$continuous_spawner_units[$i].variables.muf_x|,$continuous_spawner_units[$i].x
                        y=$continuous_spawner_units[$i].variables.muf_y|,$continuous_spawner_units[$i].y
                    [/move_unit_fake]
                [/then]
            [/if]

            [unit]
                type=$continuous_spawner_units[$i].type
                side=$continuous_spawner_units[$i].side
                x=$continuous_spawner_units[$i].x
                y=$continuous_spawner_units[$i].y
                facing=$continuous_spawner_units[$i].facing
            [/unit]
        {NEXT i}
    [/event]
#enddef

# Implementation detail. Use the specific spawn type macros instead.
#define SPAWNER_BASE _RESPAWN_TURNS _UNIT_WML _SIDE_NUMBER _X _Y _DO_RESPAWN _RESPAWN_WML _DO_RANDOM _RAND_WML _DO_MUF _MUF_WML _DO_CONTINUOUS
    [set_variables]
        name=temp_spawner_store
        mode=replace
        [value]
            {_UNIT_WML}

            side={_SIDE_NUMBER}
            x={_X}
            y={_Y}

            generate_name=yes
            random_traits=yes

            upkeep=free

            [variables]
                spawner_respawn={_DO_RESPAWN}
                spawner_event="respawn:S{_SIDE_NUMBER}X{_X}Y{_Y}"
                spawner_turns={_RESPAWN_TURNS}
                spawner_do_rand={_DO_RANDOM}
                spawner_do_continuous={_DO_CONTINUOUS}
                spawner_do_muf={_DO_MUF}
            [/variables]
        [/value]
    [/set_variables]

    {_RESPAWN_WML}
    {_RAND_WML}
    {_MUF_WML}

    {VARIABLE_RANDOM temp_spawner_store.type $temp_spawner_store.type}
    {VARIABLE_RANDOM temp_spawner_store.facing n,ne,nw,s,se,sw}

    # wmlindent: start ignoring
    {LOG_NX (
        "<SPAWNER_BASE> respawn S: $temp_spawner_store.side X: $temp_spawner_store.x Y: $temp_spawner_store.y " +
        "T: '$temp_spawner_store.type' F: $temp_spawner_store.facing R: $temp_spawner_store.variables.spawner_respawn")
    }
    # wmlindent: stop ignoring

    [if]
        {VARIABLE_LEXICAL_EQUALS temp_spawner_store.variables.spawner_do_continuous yes}
        [then]
            {VARIABLE continuous_spawner_units[$continuous_spawner_units.length] $temp_spawner_store}
        [/then]
        [else]
            [unstore_unit]
                find_vacant=yes
                variable=temp_spawner_store
            [/unstore_unit]
        [/else]
    [/if]

    {CLEAR_VARIABLE temp_spawner_store}
#enddef

##
# Macros used to expand the functionality of the spawner base. Only use these
# as args for it
##
#define SPAWNER_FUNCTION:RESPAWN
    [if]
        {VARIABLE_BOOLEAN_EQUALS temp_spawner_store.variables.spawner_respawn yes}
        [then]
            {VARIABLE_RANDOM temp_spawn_only_once_random               0..100}
            {VARIABLE_RANDOM temp_spawn_only_once_random_control_value 23,33,41,73}
            {VARIABLE_OP temp_spawn_only_once_random modulo $temp_spawn_only_once_random_control_value}

            [if]
                {VARIABLE_NUMERICAL_EQUALS temp_spawn_only_once_random 0}
                [then]
                    {VARIABLE temp_spawner_store.variables.spawner_respawn no}
                [/then]
            [/if]

            {CLEAR_VARIABLE temp_spawn_only_once_random,temp_spawn_only_once_random_control_value}
        [/then]
    [/if]
#enddef

#define SPAWNER_FUNCTION:RANDOM _RAND_FORMULA
    [if]
        {VARIABLE_BOOLEAN_EQUALS temp_spawner_store.variables.spawner_do_rand yes}
        [then]
            [store_locations]
                variable=spawner_random_locs
                {_RAND_FORMULA}
            [/store_locations]

            {VARIABLE_RANDOM rand_index    "1..$($spawner_random_locs.length| - 1)"}

            {VARIABLE temp_spawner_store.x $spawner_random_locs[$rand_index].x}
            {VARIABLE temp_spawner_store.y $spawner_random_locs[$rand_index].y}

            {LOG_NX ( _ "Spawn location randomly calculated")}

            {CLEAR_VARIABLE spawner_random_locs,rand_index}
        [/then]
    [/if]
#enddef

#define SPAWNER_FUNCTION:MUF _MUF_ORIGIN_FILTER
    [if]
        {VARIABLE_LEXICAL_EQUALS temp_spawner_store.variables.spawner_do_muf yes}
        [then]
            [store_locations]
                {_MUF_ORIGIN_FILTER}
                variable=applicable_muf_hexes
            [/store_locations]

            {VARIABLE_OP muf_hex_index rand              "0..$($applicable_muf_hexes.length - 1)"}

            {VARIABLE temp_spawner_store.variables.muf_x $applicable_muf_hexes[$muf_hex_index].x}
            {VARIABLE temp_spawner_store.variables.muf_x $applicable_muf_hexes[$muf_hex_index].y}

            {LOG_NX ( _ "Stored possible muf origin locations")}

            {CLEAR_VARIABLE applicable_muf_hexes,muf_hex_index}
        [/then]
    [/if]
#enddef

# kate: indent-mode normal; encoding utf-8; space-indent on;
